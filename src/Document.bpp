@include_once "elements/Class.bpp"
@include_once "formatting/XML.bpp"
@include_once "formatting/MD.bpp"
@include_once <TypedArray>

@class Document {
	## The directory to scan for source files.
	@private sourceDirectory
	## The output format for the documentation (can be "xml" or "md").
	@private outputFormat="xml"
	## The directory to output the documentation files to.
	@private outputDirectory
	@private @TypedArray classes
	@private @TypedArray classes_with_unknown_parents

	@constructor {
		@this.classes.set_type "Class"
		@this.classes_with_unknown_parents.set_type "Class"
	}

	@public @method setSourceDirectory directory {
		if [[ ! -d "$directory" ]]; then
			return 1
		fi
		@this.sourceDirectory="$directory"
	}
	@public @method setMode mode {
		mode=@(echo "$mode" | tr '[:upper:]' '[:lower:]')
		if [[ "$mode" == "xml" || "$mode" == "md" ]]; then
			@this.outputFormat="$mode"
			return 0
		else
			return 1
		fi
	}
	@public @method setOutputDirectory directory {
		if [[ ! -d "$directory" ]]; then
			return 1
		fi
		@this.outputDirectory="$directory"
	}

	@public @method isReady {
		if [[ -z "@this.sourceDirectory" ]] || [[ -z "@this.outputDirectory" ]]; then
			return 1
		fi
	}

	@private @method findClassByName name {
		for c in @this.classes.all; do
			@Class* class_="$c"
			if [[ @class_.name == "$name" ]]; then
				echo "$c"
				return 0
			fi
		done
		return 1
	}

	## Scans a single file for class definitions and processes them.
	@private @method scanFile file {
		local latestComment=""
		local fileContents outputLines
		local currently_parsing_multiline_comment=0

		local ignore_next_element=0 ignoring_entire_class=0

		# Specifically for METHOD processing:
		local latestReturnsComment="" latestOutputsComment=""
		# Associative array: parameter name -> description
		declare -A parameter_descriptions

		IFS= read -r -d '' fileContents < <(cat "$file")
		mapfile -t outputLines < <(echo "$fileContents")

		local line_number=0
		for line in "${outputLines[@]}"; do
			line_number=$((line_number + 1))

			# We can skip this line really quickly if we don't see '##' or '@'
			if ! grep -qE '^[[:space:]]*(##|@)' <<< "$line"; then
				# If we reach here and were parsing a multiline comment, end it
				currently_parsing_multiline_comment=0
				continue
			fi

			# Do we see an autodoc comment on this line?
			# Scan for '## comment text'
			if grep -qE '^[[:space:]]*##' <<< "$line"; then
				# Extract comment text
				local comment_text=@(grep -oE '^[[:space:]]*##[[:space:]]*.*$' <<< "$line" | sed -E 's/^[[:space:]]*##[[:space:]]*//')

				# Extract the first word to see if it's a command word (like '@param')
				# '@param' is used to document method parameters
				# '@return' or '@returns' is used to document method exit status codes
				# '@output' or '@outputs' is used to document method output values (stdout)
				# '@ignore' is used to tell autodoc to ignore the next element
				local first_word=@(awk '{print $1}' <<< "$comment_text")
				case "$first_word" in
					"\@param")
						# Extract parameter name and description
						# The format is: '@param name description...'
						# The description may be multiple words
						local param_declaration_and_description=@(echo "$comment_text" | sed -E 's/^\@param[[:space:]]+//')
						local param_name=@(echo "$param_declaration_and_description" | awk '{print $1}')
						local param_description=@(echo "$param_declaration_and_description" | sed -E "s/^$param_name[[:space:]]*//")
						parameter_descriptions["$param_name"]="$param_description"
						continue
						;;
					"\@return" | "\@returns")
						# Extract returns description (text after the keyword)
						latestReturnsComment=@(echo "$comment_text" | sed -E 's/^\@(return|returns)[[:space:]]+//')
						continue
						;;
					"\@output" | "\@outputs")
						# Extract outputs description (text after the keyword)
						latestOutputsComment=@(echo "$comment_text" | sed -E 's/^\@(output|outputs)[[:space:]]+//')
						continue
						;;
					"\@ignore")
						# Set a flag to ignore the next element (class, method, or member)
						ignore_next_element=1
						continue
						;;
					*)
						# Regular comment, continue processing below
						;;
				esac
				
				if [[ $currently_parsing_multiline_comment -eq 1 ]]; then
					latestComment+="\n$comment_text"
				else
					latestComment="$comment_text"
					currently_parsing_multiline_comment=1
				fi
				continue
			fi

			# If we reach here and were parsing a multiline comment, end it
			currently_parsing_multiline_comment=0

			# Do we see a class declaration on this line?
			# Scan for '@class ClassName [: parentClassName] {'
			if grep -qE '^[[:space:]]*@class[[:space:]]+[A-Za-z_][A-Za-z0-9_]*([[:space:]]*:[[:space:]]*[A-Za-z_][A-Za-z0-9_]*)?[[:space:]]*\{' <<< "$line"; then
				if [[ $ignore_next_element -eq 1 ]]; then
					ignore_next_element=0
					ignoring_entire_class=1
					latestComment=""
					continue
				fi
				if [[ $ignoring_entire_class -eq 1 ]]; then
					# We just finished ignoring an entire class (incl. all of its members, methods)
					# We hit here **after** that class, when we then see **another** class declaration (which should not be ignored)
					# Reset the flag and carry on
					ignoring_entire_class=0
				fi
				# Extract class name and optional parent class name
				local class_declaration=@(grep -oE '^[[:space:]]*@class[[:space:]]+[A-Za-z_][A-Za-z0-9_]*([[:space:]]*:[[:space:]]*[A-Za-z_][A-Za-z0-9_]*)?[[:space:]]*\{' <<< "$line")
				local class_name=@(echo "$class_declaration" | grep -oE '[A-Za-z_][A-Za-z0-9_]*' | head -n 2 | tail -n 1)
				local parent_class_name=""
				if grep -qE ':[[:space:]]*[A-Za-z_][A-Za-z0-9_]*' <<< "$class_declaration"; then
					parent_class_name=@(echo "$class_declaration" | grep -oE ':[[:space:]]*[A-Za-z_][A-Za-z0-9_]*' | head -n 1 | tr -d ' :')
				fi

				@Class* class_=@new Class
				@class_.name="$class_name"
				@class_.sourceFile="@(basename $file)"
				if [[ -n "$parent_class_name" ]]; then
					@class_.parentClassName="$parent_class_name"
					if ! @class_.inherit "@(@this.findClassByName "$parent_class_name")"; then
						# Parent class not found yet, will need to resolve later
						>&2 echo "Note: Parent class '$parent_class_name' for class '$class_name' not found yet, will resolve later"
						@this.classes_with_unknown_parents.push "@class_"
					fi
				fi
				# Otherwise, the parent has been set via inherit method
				# And all members/methods have been inherited (apart from those overridden)

				echo "Processing class '@{class_.name}' in file '$file' [line $line_number]"
				@this.classes.push "@class_"

				# If there's a latest comment, set it as the class description
				if [[ -n "$latestComment" ]]; then
					@class_.description="$latestComment"
					latestComment=""
				fi
				continue
			fi

			# Do we see a data member declaration on this line?
			# Scan for '@(public|private|protected) identifier'
			# OR: '@(public|private|protected) @Type[*] identifier'
			if grep -qE '^[[:space:]]*@(public|private|protected)[[:space:]]+(@[A-Za-z_][A-Za-z0-9_]*\*?[[:space:]]+)?[A-Za-z_][A-Za-z0-9_]*(=.+)?$' <<< "$line"; then
				if [[ $ignore_next_element -eq 1 ]] || [[ $ignoring_entire_class -eq 1 ]]; then
					ignore_next_element=0
					latestComment=""
					continue
				fi
				if @this.classes.empty; then
					>&2 echo "Error: Found member declaration outside of class in file '$file' [line $line_number]"
					continue
				fi
				# Extract scope, optional type, and member name
				local member_declaration=@(grep -oE '^[[:space:]]*@(public|private|protected)[[:space:]]+(@[A-Za-z_][A-Za-z0-9_]*\*?[[:space:]]+)?[A-Za-z_][A-Za-z0-9_]*' <<< "$line")
				local scope=@(echo "$member_declaration" | grep -oE '@(public|private|protected)' | tr -d '@')
				local member_declaration_without_scope=@(echo "$member_declaration" | sed -E 's/^[[:space:]]*@(public|private|protected)[[:space:]]+//')
				local type_and_name=@(echo "$member_declaration_without_scope" | grep -oE '(@[A-Za-z_][A-Za-z0-9_]*\*?[[:space:]]+)?[A-Za-z_][A-Za-z0-9_]*')
				local type="Primitive"
				local member_name=""

				if grep -qE '^@[A-Za-z_][A-Za-z0-9_]*\*?[[:space:]]+' <<< "$type_and_name"; then
					type=@(echo "$type_and_name" | grep -oE '^@[A-Za-z_][A-Za-z0-9_]*\*?' | tr -d '@ ')
					member_name=@(echo "$type_and_name" | grep -oE '[A-Za-z_][A-Za-z0-9_]*$')
				else
					member_name="$type_and_name"
				fi

				@Class* current_class=@this.classes.back
				local typeString=""
				if [[ "$type" != "Primitive" ]]; then
					typeString="\@$type "
				fi
				echo "  Adding datamember: \@${scope} ${typeString}\@@{current_class.name}.${member_name} [line $line_number]"

				@Member* member_=@new Member
				@member_.name="$member_name"
				@member_.type="$type"
				@member_.scope="$scope"
				@current_class.addMember "@member_" &>/dev/null

				# If there's a latest comment, set it as the member description
				if [[ -n "$latestComment" ]]; then
					@member_.description="$latestComment"
					latestComment=""
				fi
				continue
			fi

			# Do we see a method declaration on this line?
			# Scan for '[@virtual] @(public|private|protected) @method methodName [param1 @Type* param2 ...] {'
			if grep -qE '^[[:space:]]*(@virtual[[:space:]]+)?@(public|private|protected)[[:space:]]+@method[[:space:]]+[A-Za-z_][A-Za-z0-9_]*([[:space:]]+(@[A-Za-z_][A-Za-z0-9_]*\*?[[:space:]]+)?[A-Za-z_][A-Za-z0-9_]*)*[[:space:]]*\{' <<< "$line"; then
				if [[ $ignore_next_element -eq 1 ]] || [[ $ignoring_entire_class -eq 1 ]]; then
					ignore_next_element=0
					latestComment=""
					continue
				fi
				if @this.classes.empty; then
					>&2 echo "Error: Found method declaration outside of class in file '$file' [line $line_number]"
					continue
				fi
				# Extract virtual flag, scope, method name, and parameters
				local method_declaration=@(grep -oE '^[[:space:]]*(@virtual[[:space:]]+)?@(public|private|protected)[[:space:]]+@method[[:space:]]+[A-Za-z_][A-Za-z0-9_]*([[:space:]]+(@[A-Za-z_][A-Za-z0-9_]*\*?[[:space:]]+)?[A-Za-z_][A-Za-z0-9_]*)*[[:space:]]*\{' <<< "$line")
				local is_virtual=0
				if grep -qE '^@[[:space:]]*virtual' <<< "$method_declaration"; then
					is_virtual=1
				fi
				local scope=@(echo "$method_declaration" | grep -oE '@(public|private|protected)' | tr -d '@')
				local method_name=@(echo "$method_declaration" | grep -oE ' [A-Za-z_][A-Za-z0-9_]*' | tr -d ' ' | head -n 1)

				local parameters_section=@(echo "$method_declaration" | sed -E 's/^[[:space:]]*(@virtual[[:space:]]+)?@(public|private|protected)[[:space:]]+@method[[:space:]]+[A-Za-z_][A-Za-z0-9_]*//; s/\{[[:space:]]*$//')
				# Parse the parameters_section into individual parameters
				# Each parameter is of the form: '[@Type*] paramName'
				# That is, it can be written as either 'paramName' or '@Type* paramName'
				# We'll need to create a Parameter object for each parameter and add it to the method
				local parameter_tokens=()
				if [[ -n "$parameters_section" ]]; then
					# Split by whitespace, then reassemble parameters
					read -r -a raw_tokens <<< "$parameters_section"
					local i=0
					while [[ $i -lt ${#raw_tokens[@]} ]]; do
						local token="${raw_tokens[$i]}"
						if [[ "$token" == \@* ]]; then
							# This token is a type, so the next token must be the parameter name
							if [[ $((i + 1)) -lt ${#raw_tokens[@]} ]]; then
								local param_name="${raw_tokens[$((i + 1))]}"
								parameter_tokens+=("$token $param_name")
								i=$((i + 2))
							else
								>&2 echo "Error: Incomplete parameter declaration in method '$method_name' in file '$file' [line $line_number]"
								break
							fi
						else
							# This token is a parameter name without a type
							# That's a primitive parameter
							parameter_tokens+=("$token")
							i=$((i + 1))
						fi
					done
				fi

				echo "  Adding method: \@${scope} \@method ${method_name} ${parameters_section} [line $line_number]"

				@Class* current_class=@this.classes.back

				@Method* method_=@new Method
				@method_.name="$method_name"
				@method_.scope="$scope"
				if [[ $is_virtual -eq 1 ]]; then
					@method_.virtual=1
				fi
				@current_class.addMethod "@method_" &>/dev/null

				# If there's a latest comment, set it as the method description
				if [[ -n "$latestComment" ]]; then
					@method_.description="$latestComment"
					latestComment=""
				fi

				# If there's a returns comment, set it
				if [[ -n "$latestReturnsComment" ]]; then
					@method_.returnsComment="$latestReturnsComment"
					latestReturnsComment=""
				fi

				# If there's an outputs comment, set it
				if [[ -n "$latestOutputsComment" ]]; then
					@method_.outputsComment="$latestOutputsComment"
					latestOutputsComment=""
				fi

				# Iterate over parameter tokens and create Parameter objects
				for param_token in "${parameter_tokens[@]}"; do
					local param_type="Primitive"
					local param_name=""

					if grep -qE '^@[A-Za-z_][A-Za-z0-9_]*\*?[[:space:]]+' <<< "$param_token"; then
						param_type=@(echo "$param_token" | grep -oE '^@[A-Za-z_][A-Za-z0-9_]*\*?' | tr -d '@ ')
						param_name=@(echo "$param_token" | grep -oE '[A-Za-z_][A-Za-z0-9_]*$')
					else
						param_name="$param_token"
					fi

					@Parameter* parameter_=@new Parameter
					@parameter_.name="$param_name"
					@parameter_.type="$param_type"

					# If there's a description for this parameter, set it
					if [[ -n "${parameter_descriptions[$param_name]}" ]]; then
						@parameter_.description="${parameter_descriptions[$param_name]}"
					fi

					@method_.addParameter "@parameter_"
				done

				# Clear parameter descriptions for next method
				parameter_descriptions=()
				continue
			fi
		done
	}

	## Scans the source directory for all files and processes them.
	@public @method scanDirectory {
		if [[ ! -d "@this.sourceDirectory" ]]; then
			>&2 echo "Error: Source directory '@this.sourceDirectory' does not exist"
			return 1
		fi

		for file in @(find "@this.sourceDirectory" -type f); do
			@this.scanFile "$file"
		done

		# If any classes had unknown parents, try to resolve them now
		for c in @this.classes_with_unknown_parents.all; do
			@Class* class_="$c"
			if ! @class_.inherit "@(@this.findClassByName "@class_.parentClassName")"; then
				>&2 echo "Warning: Could not resolve parent class '@{class_.parentClassName}' for class '@{class_.name}'"
			else
				>&2 echo "Resolved parent class '@{class_.parentClassName}' for class '@{class_.name}'"
			fi
		done
	}

	## Prints the documentation in the specified output format.
	@public @method print {
		@DocumentFormat* format
		if [[ "@this.outputFormat" == "xml" ]]; then
			@format=@new XMLFormat
		elif [[ "@this.outputFormat" == "md" ]]; then
			@format=@new MDFormat
		else
			>&2 echo "Error: Unknown output format '@this.outputFormat'"
			return 1
		fi

		for c in @this.classes.all; do
			@Class* class_="$c"
			
			local output_file="@this.outputDirectory/@{class_.name}.@{format.extension}"

			>&2 echo "Generating documentation for class '@{class_.name}' in file '$output_file'"

			@format.printClass "@class_" > "$output_file"
		done
	}
}
